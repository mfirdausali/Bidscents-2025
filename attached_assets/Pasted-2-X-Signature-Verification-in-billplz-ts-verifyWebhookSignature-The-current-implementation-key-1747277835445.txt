2. X-Signature Verification in billplz.ts:

verifyWebhookSignature:

The current implementation: keys.map(key =>key{payloadForSignature[key]}).join('|') seems correct based on Billplz documentation examples for webhooks where the key-value string itself is what's sorted and joined. Double-check that boolean values (paid) are handled as strings ("true"/"false") in the payloadForSignature if that's how Billplz sends them in the webhook body.
verifyRedirectSignature (Needs Major Refinement):

Your current logic in server/routes.ts for /api/payments/process-redirect has a custom implementation to build the sourceString. This is complex and error-prone.

The billplz.ts module already has a verifyRedirectSignature function, but it's also quite complex in its parameter extraction.

Crucial: The Billplz documentation (page 45 of the PDF) specifies that for redirect URLs, the source string components are formed from the full parameter names and their values, e.g., billplz[id]${idValue}, billplz[paid]${paidValue}. These full strings are then sorted alphabetically and joined by |.

Suggestion: Simplify and correct billplz.verifyRedirectSignature.

TypeScript

// In billplz.ts
export function verifyRedirectSignature(
    rawQueryString: string, // Pass the raw query string (e.g., from req.rawQuery)
    expectedXSignature: string
): boolean {
    if (!BILLPLZ_XSIGN_KEY) {
        console.error('Missing BILLPLZ_XSIGN_KEY environment variable');
        return false;
    }
    if (!rawQueryString) {
        console.error('Raw query string is empty for redirect signature verification.');
        return false;
    }

    console.log('üîê REDIRECT SIGNATURE VERIFICATION START üîê');
    console.log('Raw Query:', rawQueryString);
    console.log('Expected X-Signature:', expectedXSignature);

    const params = new URLSearchParams(rawQueryString);
    const elementsToSign: string[] = [];

    // Iterate over all parameters to construct elements like "billplz[key]value"
    // Billplz documentation for redirects (page 45) example uses:
    // billplzidzq0tm2wc
    // billplzpaid_at2018-09-27 15:15:09 +0800
    // billplzpaidtrue
    // These are then sorted and joined by |
    // This implies we need to collect "keyvalue" strings where "key" is the full query param name

    for (const [key, value] of params.entries()) {
        if (key !== 'billplz[x_signature]') { // Exclude the signature itself
            elementsToSign.push(`<span class="math-inline">\{key\}</span>{value}`);
        }
    }

    // Sort in ascending order, case-insensitive (as per general X-Signature rules)
    // Although Billplz redirect examples usually show few params, general rule is good.
    elementsToSign.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

    const sourceString = elementsToSign.join('|');
    console.log('Concatenated Source String for Redirect HMAC:', sourceString);

    const hmac = crypto.createHmac('sha256', BILLPLZ_XSIGN_KEY);
    hmac.update(sourceString);
    const calculatedSignature = hmac.digest('hex');

    console.log('Calculated Redirect Signature:', calculatedSignature);

    try {
        const isEqual = crypto.timingSafeEqual(
            Buffer.from(calculatedSignature, 'hex'),
            Buffer.from(expectedXSignature, 'hex')
        );
        console.log(`RESULT: ${isEqual ? 'VALID ‚úÖ' : 'INVALID ‚ùå'}`);
        console.log('üîê REDIRECT SIGNATURE VERIFICATION END üîê');
        return isEqual;
    } catch (e) {
        console.error('Error in timing-safe comparison for redirect:', e);
        // Fallback for length mismatch or other crypto errors
        const isEqual = calculatedSignature === expectedXSignature;
        console.log(`RESULT (fallback): ${isEqual ? 'VALID ‚úÖ' : 'INVALID ‚ùå'}`);
        console.log('üîê REDIRECT SIGNATURE VERIFICATION END üîê');
        return isEqual;
    }
}
Then, in server/routes.ts for /api/payments/process-redirect:

TypeScript

// In server/routes.ts, inside GET /api/payments/process-redirect
// ...
// const signatureMatch = req.rawQuery.match(/(?:^|&)billplz\[x_signature\]=([0-9a-f]{64})(?:&|$)/);
// if (!signatureMatch) { /* ... error ... */ }
// const signatureFromUrl = signatureMatch[1];

// A simpler way to get the signature from Express parsed query:
const signatureFromUrl = req.query['billplz[x_signature]'] as string;
if (!signatureFromUrl) {
     console.error('‚ùå ERROR: Missing billplz[x_signature] in query parameters');
     return res.status(400).json({ /* ... */ });
}
console.log('üîë Extracted signature from query:', signatureFromUrl);


// Pass the raw query string (req.rawQuery) and the extracted signature
// The rawQuery should NOT have the signature parameter itself for building the source string.
// Or, the verifyRedirectSignature function should handle removing/ignoring it.
// The updated verifyRedirectSignature above handles ignoring it.

const isSignatureValid = billplz.verifyRedirectSignature(req.rawQuery, signatureFromUrl);

if (!isSignatureValid) {
    console.error('‚ùå ERROR: Redirect signature verification failed');
    return res.status(401).json({ /* ... */ });
}
// ... rest of the logic using req.query to get other billplz[key] values
const paymentData = {
    id: req.query['billplz[id]'] as string,
    paid: req.query['billplz[paid]'] as string, // Will be 'true' or 'false'
    paid_at: req.query['billplz[paid_at]'] as string,
    reference_1: req.query['billplz[reference_1]'] as string, // orderId
    reference_2: req.query['billplz[reference_2]'] as string, // productIds
    // Optional:
    // transaction_id: req.query['billplz[transaction_id]'] as string,
    // transaction_status: req.query['billplz[transaction_status]'] as string,
};
// ...