Complete plan for handling the Billplz browser-redirect step
(The goal is a smooth “Payment Success / Failure” screen that never interferes with the ledger already written by the webhook.)

1. Decide where the redirect lands
Public route: /api/payments/process-redirect (already set in every Bill URL).

Public page: /seller/dashboard?payment={success|failed|error}&message=… (where you actually show a toast or banner).

The route does the cryptography and displacement logic; the page simply reads query-string flags.

2. Accept the request exactly as Billplz sends it
Method: GET

Query string: looks like

bash
Copy
Edit
?billplz[id]=17cd…&billplz[paid]=true&billplz[paid_at]=2025-05-10+01:12:31+%2B0800&billplz[x_signature]=…
No body and no headers to parse—every piece of data is in that query string.

Rule of thumb If you see plus signs (+) for the timezone and square-bracketed keys, you are still working with the “raw” form Billplz signed.

3. Parse, but preserve raw keys and plus signs
Express 4.18+ by default gives you:

js
Copy
Edit
req.query.billplz = {
  id: '…',
  paid: 'true',
  paid_at: '2025-05-10 01:12:31 +0800',
  x_signature: '…'
}
Older Express or a custom query parser may leave them flat:

js
Copy
Edit
req.query['billplz[id]'] = '…'
Implementation tip

js
Copy
Edit
const pouch =
  req.query.billplz            // object form
  ?? req.query;                // flat fallback
4. Re-create the exact source string for HMAC
Clone the pouch and delete x_signature.

Sort its keys as they appear (billplz[id], billplz[paid], …).

Build

ini
Copy
Edit
source = k1 + v1 | k2 + v2 | k3 + v3 | k4 + v4
• No = signs • No URL-decoding of + to space.

A quick self-check with the example above should yield:

less
Copy
Edit
billplz[id]17cd…|billplz[paid]true|billplz[paid_at]2025-05-10 01:12:31 +0800|billplz[transaction_id]…|billplz[transaction_status]completed
(no trailing pipe).

5. Verify the signature
text
Copy
Edit
calc = HMAC_SHA256(source, BILLPLZ_XSIGN_KEY)
if calc === signature → ok
else → fail
Compare in constant time to avoid timing attacks.

6. Map the outcome to user-facing URLs
verification	billplz[paid]	redirect target
valid	'true'	/seller/dashboard?payment=success&message=Thanks+for+paying!
valid	'false'	/seller/dashboard?payment=failed&message=Payment+was+cancelled+or+rejected
invalid signature	n/a	/seller/dashboard?payment=error&message=We+could+not+confirm+your+payment

Never change database state here—only read it later to show live status.

7. Front-end display expectations
If your dashboard is a SPA, watch for payment and message query params:

success → toast “Payment received! Your listing will be boosted soon.”

failed → toast “Payment cancelled or insufficient funds.”

error → toast “We couldn’t confirm your payment; please wait a moment or contact support.”

Optionally poll /api/payments/status/:orderId for a few seconds to reflect the webhook’s final state.

8. Logging & analytics
Log every redirect hit with {bill_id, verified, paid_flag, ip}—helps reconcile odd cases.

Emit a metric (redirect.success, redirect.failed, redirect.invalidsig).

9. Failure-mode playbook
situation	what user sees	next automatic recovery
user closes tab before redirect	nothing	webhook already updated DB; your UI will show boosted status on the next page load.
redirect signature invalid (rare)	“We couldn’t confirm your payment” banner	reconcile job will query Billplz within an hour and update DB.
webhook arrives after redirect	redirect shows “pending…” until poll sees status='paid'.	

10. Test matrix before go-live
test	expected result
Pay with sandbox bank → complete	Redirect URL shows success, DB status='paid'
Pay then abort at bank page	Redirect URL shows failed, DB stays due
Tamper with any query param in the URL	Redirect shows error because signature fails

Once you can’t break those three cases, your browser-side UX layer is solid—payment truth will always be dictated by the server-to-server webhook, and the customer sees instant, trustworthy feedback.