0 Pre-flight facts that drive the whole design
Fact	Why it matters in Express 4.21.2
Query parsing is done by qs v6.x under the hood.	+ in the raw string is decoded to space ( ).
Keys like billplz[id] are de-nested to req.query.billplz.id.	You lose the original bracketed key names Billplz signed.
Billplz signs exactly the raw query string before URL-decoding.	You must capture that raw string before qs touches it.

1 Install one early middleware that stashes the raw query
Place it before every other parser (express.json, express.urlencoded, etc.).

Path-scope it to the redirect route only.

Purpose: freeze the byte sequence that came off the TCP socket.

javascript
Copy
Edit
app.use('/api/payments/process-redirect', (req, _res, next) => {
  req.rawQuery = req.originalUrl.split('?')[1] || '';   // capture everything after “?”
  next();
});
Outcome: req.rawQuery still contains
billplz[id]=17cd…&billplz[paid]=true&billplz[paid_at]=2025-05-10+01%3A12%3A31+%2B0800&billplz[x_signature]=…

2 Extract the x_signature without decoding anything
Regex search inside req.rawQuery

css
Copy
Edit
/(?:^|&)billplz\[x_signature]=([0-9a-f]{64})/
Save capture group 0 → sigHEX.

Remove that key-value pair from the raw string (keep leading or trailing & tidy).
Now you hold the exact unsigned query.

3 Build the HMAC source string byte-for-byte
pairs = unsignedQuery.split('&') // still raw

pairs.sort() // ASCII natural order

pieces = pairs.map(p => p.replace('=', '')) // join key+value

source = pieces.join('|')

Example result (no trailing pipe):

less
Copy
Edit
billplz[id]17cd…|billplz[paid]true|billplz[paid_at]2025-05-10 01:12:31 +0800|billplz[transaction_id]…|billplz[transaction_status]completed
Note the space before +0800 remains because the plus is still encoded in the raw string as %2B, not decoded.

4 Verify the signature
Create h = crypto.createHmac('sha256', process.env.BILLPLZ_XSIGN_KEY).

calc = h.update(source, 'utf8').digest('hex').

Compare with sigHEX using crypto.timingSafeEqual.

Reject (302 to error UI) on any mismatch or if the regex failed to find a signature.

5 Never mutate the ledger here — decide which UI to show
Look up the payment row in DB using bill_id (inside the query, now parse-safe).

Decide uiState:

DB status	What redirect displays
paid	success banner
failed	failed banner
due	pending banner
not found	error banner

res.redirect('/seller/dashboard?payment=' + uiState).
(Add an encoded message param if you like.)

6 Handle race with webhook
If redirect arrives first (status = due):

Front-end shows “pending… verifying”, then polls /api/payments/:orderId/status every 3 s for up to 30 s.

Webhook will flip the DB row to paid within seconds; the poll ends and the UI changes automatically.

No extra backend work needed.

7 Observability hooks
INFO log a JSON line:

json
Copy
Edit
{"tag":"bp-redirect","bill_id":"17cd…","verified":true,"db_status":"paid","latency_ms":12}
WARN metric if verified=true but db_status='due' after 30 s (webhook lag).

ALERT if verified=false spike > 1 % (signature issues).

8 Unit fuzz checklist
Feed 10 k query strings in random key order → verification must pass.

Flip one hex char in signature → must reject.

Replace %2B with literal + → must reject (proves you’re using raw string).

Replay the same redirect 50× → handler stays idempotent and sub-15 ms.

9 Zero-downtime deploy plan
Deploy middleware + new handler in shadow mode: verify signature, log result, but still follow old flow.

After 24 h, confirm verified:true rate ≥ 99.999 %.

Flip feature flag to make new handler authoritative; remove legacy branch.

result
With these atomic steps, your Express 4.21.2 app:

Verifies the redirect HMAC 100 % byte-accurately.

Presents instant, truthful feedback to the user.

Never risks double-updating the payment ledger.

Gracefully handles webhook/redirect arrival ordering.