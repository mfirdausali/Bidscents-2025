# Security Vulnerability Remediation Prompt

<prompt_explanation>
You are an expert security engineer tasked with systematically fixing critical authentication and authorization vulnerabilities in a web application. Your goal is to eliminate all identified security risks through a structured, comprehensive remediation approach that ensures system integrity while maintaining functionality.

First, carefully analyze the provided security audit report. Understand each vulnerability's impact, attack vectors, and interconnected risks. Spend significant time considering the relationships between different security issues and how fixing one might affect others.

Next, develop a comprehensive remediation strategy that addresses all vulnerabilities in order of criticality. For each security issue, specify the following in a table:

- Vulnerability: The specific security flaw being addressed
- Severity Level: Critical/High/Medium priority classification
- Attack Vector: How this vulnerability could be exploited
- Fix Strategy: The technical approach to resolve the issue
- Dependencies: Other fixes that must be completed first
- Validation Method: How to verify the fix is effective

After defining all remediation approaches in tabular format, write out the actual implementation code for each fix. Ensure each solution follows these security principles:

1. **Defense in Depth**: Multiple layers of security controls
2. **Principle of Least Privilege**: Minimal necessary access rights
3. **Fail Secure**: System fails to a secure state when errors occur
4. **Input Validation**: All inputs are validated and sanitized
5. **Secure by Default**: Secure configurations are the default

For each implementation, provide clear comments explaining the security rationale and any important considerations.

Once all fixes have been implemented, provide a comprehensive testing strategy to validate that vulnerabilities are resolved without breaking existing functionality.

Finally, deliver ongoing security recommendations and monitoring guidelines to prevent future vulnerabilities.
</prompt_explanation>

<response_format>
<vulnerability_analysis_section>
<header>Security Vulnerability Analysis:</header>
<analysis>$vulnerability_analysis</analysis>
</vulnerability_analysis_section>

<remediation_strategy_section>
<header>Remediation Strategy:</header>
<table>
<header_row>
<column1>Vulnerability</column1>
<column2>Severity Level</column2>
<column3>Attack Vector</column3>
<column4>Fix Strategy</column4>
<column5>Dependencies</column5>
<column6>Validation Method</column6>
</header_row>
$remediation_table
</table>
</remediation_strategy_section>

<implementation_code_section>
<header>Security Fix Implementation:</header>
$security_fix_code
</implementation_code_section>

<testing_validation_section>
<header>Security Testing & Validation:</header>
<testing>$security_testing</testing>
</testing_validation_section>

<monitoring_prevention_section>
<header>Ongoing Security Measures:</header>
<monitoring>$security_monitoring</monitoring>
<prevention>$vulnerability_prevention</prevention>
</monitoring_prevention_section>
</response_format>

Here is the security audit report that you must systematically address:

<security_audit_report>
CRITICAL AUTHENTICATION SECURITY ANALYSIS

üö® MAJOR SECURITY VULNERABILITIES

1. DUAL AUTHENTICATION SYSTEM CHAOS
SEVERITY: CRITICAL
You have TWO COMPLETELY DIFFERENT authentication systems running simultaneously:
- System A: use-auth.tsx (legacy with username/password + Supabase)
- System B: use-supabase-auth.tsx (pure Supabase)
IMMEDIATE RISK: User can bypass authentication by switching between systems.

2. HARDCODED DEFAULT JWT SECRET
SEVERITY: CRITICAL
// server/app-auth.ts:13
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
// server/jwt.ts:4  
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';
RISK: If JWT_SECRET env var is missing, anyone can forge tokens with known default.

3. INCONSISTENT TOKEN STORAGE
SEVERITY: HIGH
- queryClient.ts uses auth_token key
- use-supabase-auth.tsx checks for app_token key
- Different parts expect different token names
RISK: Authentication state desync leading to unauthorized access.

4. NO WEBSOCKET AUTHENTICATION
SEVERITY: HIGH
// server/routes.ts:78-84
case 'auth':
  if (data.userId && data.username) {
    clients.set(ws, { userId: data.userId, username: data.username });
    // NO TOKEN VERIFICATION!
  }
RISK: Anyone can claim any user ID in WebSocket messages.

5. MIXED API ENDPOINTS
SEVERITY: HIGH
- Some endpoints use /api/user
- Some use /api/v1/auth/me
- Different authentication middleware on different routes

üçù SPAGHETTI CODE REDUNDANCIES

1. DUPLICATE JWT LIBRARIES
- server/app-auth.ts has custom JWT functions
- server/jwt.ts has identical JWT functions
- Both import jsonwebtoken separately

2. DUPLICATE USER LOOKUP LOGIC
// In app-auth.ts
let localUser = await storage.getUserByEmail(user.email);
// In different places
await storage.getUserByProviderId(user.id);
await storage.getUserByUsername(username);

3. DUPLICATE AUTHENTICATION HOOKS
- useAuth() in use-auth.tsx
- useAuth() in use-supabase-auth.tsx
- SAME FUNCTION NAME, DIFFERENT BEHAVIOR

4. INCONSISTENT ERROR HANDLING
- Some functions throw errors
- Some return null
- Some return error objects
- No consistent error contract

üîê TOKEN HANDLING NIGHTMARES

1. TOKEN LIFETIME MISMATCH
- Supabase tokens: Default expiry
- App JWT: 7d in app-auth.ts
- App JWT: 24h in jwt.ts
- No token refresh mechanism

2. MULTIPLE TOKEN VALIDATION PATHS
// Path 1: Direct Supabase validation
const { data: { user }, error } = await supabase.auth.getUser(token);
// Path 2: App JWT validation  
const decoded = verifyAppJWT(token);
// Path 3: Legacy JWT validation
const decoded = jwt.verify(token, JWT_SECRET);

3. INSECURE TOKEN EXCHANGE
// app-auth.ts:154 - Session endpoint
// Accepts any Supabase token and creates app JWT
// NO RATE LIMITING, NO VALIDATION OF TOKEN SOURCE

üö™ UNAUTHORIZED ACCESS VECTORS

1. Protected Route Bypass
ProtectedRoute only checks user object exists, not token validity:
if (!user) {
  return <Redirect to="/auth" />;
}
// NO JWT EXPIRY CHECK!

2. API Route Inconsistency
- Some routes use requireAuth middleware
- Some routes use verifySupabaseAuth
- Some routes have NO AUTHENTICATION

3. Admin/Seller Privilege Escalation
// No server-side verification of isSeller/isAdmin claims
// Relies entirely on client-side JWT payload
if (path.includes("seller") && !user.isSeller) {

üéØ IMMEDIATE FIX PRIORITIES

CRITICAL (Fix TODAY)
1. Remove duplicate auth system - Choose ONE (recommend Supabase-only)
2. Set proper JWT_SECRET in production environment
3. Fix WebSocket authentication - Verify JWT tokens
4. Standardize token storage - Use one key name

HIGH (Fix this week)
1. Implement token refresh mechanism
2. Add server-side role verification for protected routes
3. Consolidate API endpoints to single auth pattern
4. Add rate limiting to auth endpoints

MEDIUM (Fix soon)
1. Remove redundant JWT files
2. Standardize error handling
3. Add proper logging for auth events
4. Implement session invalidation
</security_audit_report>

<current_codebase_structure>
{{PASTE_YOUR_CODEBASE_STRUCTURE_AND_RELEVANT_FILES_HERE}}
</current_codebase_structure>

<security_requirements>
- Must maintain existing user functionality during migration
- All tokens must be properly validated and secured
- Implement proper session management with refresh tokens  
- Add comprehensive audit logging for all auth events
- Ensure OWASP compliance for authentication and authorization
- Implement proper error handling that doesn't leak information
- Add rate limiting and brute force protection
- Ensure secure WebSocket authentication
- Implement proper role-based access control (RBAC)
- Add security headers and CSRF protection
</security_requirements>

<testing_requirements>
- Unit tests for all authentication functions
- Integration tests for auth flows
- Security penetration testing checklist
- Token validation and expiry testing
- WebSocket security testing
- Role-based access control testing
- Rate limiting and abuse prevention testing
</testing_requirements>