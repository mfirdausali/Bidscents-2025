/**
 * Authorization Vulnerability Patch for BidScents
 * 
 * This patch fixes critical authorization bypass vulnerabilities where
 * endpoints were accepting sellerId from request body/query instead of
 * using the authenticated user's ID.
 * 
 * Apply this patch to server/routes.ts to fix the vulnerabilities.
 */

// ============================================================================
// PATCH 1: Fix Product Update Endpoint (around line 2231)
// ============================================================================

// REPLACE THIS VULNERABLE CODE:
/*
app.put("/api/products/:id", async (req, res, next) => {
  try {
    // First check if the user is authenticated via session
    let sellerId = 0;
    const user = await getAuthenticatedUser(req); if (user) {
      if (!user.isSeller) {
        return res.status(403).json({ message: "Unauthorized: Seller account required" });
      }
      sellerId = user.id;
    } else if (req.body.sellerId) {
      // If not via session, check if sellerId was provided in the request body
      sellerId = parseInt(req.body.sellerId.toString());
      
      // Verify user exists and is a seller
      const userCheck = await storage.getUser(sellerId);
      if (!userCheck) {
        return res.status(403).json({ message: "Unauthorized: User not found" });
      }
      
      if (!userCheck.isSeller) {
        return res.status(403).json({ message: "Unauthorized: Seller account required" });
      }
    } else {
      return res.status(403).json({ message: "Unauthorized: User not authenticated" });
    }
*/

// WITH THIS SECURE CODE:
app.put("/api/products/:id", authService.requireAuth, async (req: any, res, next) => {
  try {
    // SECURITY FIX: Always use authenticated user, never trust client-provided sellerId
    const user = req.user;
    
    if (!user.isSeller) {
      return res.status(403).json({ 
        message: "Unauthorized: Seller account required",
        code: "SELLER_REQUIRED"
      });
    }

    const id = parseInt(req.params.id);
    const product = await storage.getProductById(id);

    if (!product) {
      return res.status(404).json({ message: "Product not found" });
    }

    // SECURITY FIX: Verify ownership
    if (product.sellerId !== user.id) {
      return res.status(403).json({ 
        message: "Unauthorized: You can only edit your own products",
        code: "OWNERSHIP_REQUIRED"
      });
    }

    // SECURITY FIX: Force sellerId to authenticated user
    const validatedData = insertProductSchema.parse({
      ...req.body,
      sellerId: user.id
    });

    const updatedProduct = await storage.updateProduct(id, validatedData);
    res.json(updatedProduct);
  } catch (error) {
    next(error);
  }
});

// ============================================================================
// PATCH 2: Fix Product Delete Endpoint (around line 2560)
// ============================================================================

// REPLACE THE VULNERABLE DELETE ENDPOINT WITH:
app.delete("/api/products/:id", authService.requireAuth, async (req: any, res, next) => {
  try {
    const user = req.user;
    
    if (!user.isSeller) {
      return res.status(403).json({ 
        message: "Unauthorized: Seller account required",
        code: "SELLER_REQUIRED"
      });
    }

    const productId = parseInt(req.params.id);
    const product = await storage.getProductById(productId);

    if (!product) {
      return res.status(404).json({ message: "Product not found" });
    }

    // SECURITY FIX: Verify ownership
    if (product.sellerId !== user.id) {
      return res.status(403).json({ 
        message: "Unauthorized: You can only delete your own products",
        code: "OWNERSHIP_REQUIRED"
      });
    }

    // Check for active auctions
    const activeAuctions = await storage.getActiveAuctionsByProductId(productId);
    if (activeAuctions.length > 0) {
      return res.status(400).json({ 
        message: "Cannot delete product with active auctions",
        code: "ACTIVE_AUCTIONS_EXIST"
      });
    }

    await storage.deleteProduct(productId);
    res.json({ message: "Product deleted successfully" });
  } catch (error) {
    next(error);
  }
});

// ============================================================================
// PATCH 3: Fix Auction Update Endpoint (around line 2281)
// ============================================================================

// REPLACE THE VULNERABLE AUCTION UPDATE WITH:
app.put("/api/auctions/:id", authService.requireAuth, async (req: any, res, next) => {
  try {
    const user = req.user;
    
    if (!user.isSeller) {
      return res.status(403).json({ 
        message: "Unauthorized: Seller account required",
        code: "SELLER_REQUIRED"
      });
    }

    const auctionId = parseInt(req.params.id);
    const auction = await storage.getAuctionById(auctionId);
    
    if (!auction) {
      return res.status(404).json({ message: "Auction not found" });
    }
    
    const product = await storage.getProductById(auction.productId);
    if (!product) {
      return res.status(404).json({ message: "Product not found" });
    }
    
    // SECURITY FIX: Verify ownership through product
    if (product.sellerId !== user.id) {
      return res.status(403).json({ 
        message: "Unauthorized: You can only edit your own auctions",
        code: "OWNERSHIP_REQUIRED"
      });
    }
    
    // Update product if provided
    if (req.body.product) {
      const productData = {
        ...req.body.product,
        sellerId: user.id // Force correct seller ID
      };
      
      const validatedProductData = insertProductSchema.parse(productData);
      await storage.updateProduct(product.id, validatedProductData);
    }
    
    // Update auction with restrictions if bids exist
    if (req.body.auction) {
      const auctionData = req.body.auction;
      
      if (auction.currentBid && auction.currentBid > 0) {
        // Limited updates when bids exist
        const safeAuctionData = {
          buyNowPrice: auctionData.buyNowPrice,
        };
        await storage.updateAuction(auctionId, safeAuctionData);
      } else {
        await storage.updateAuction(auctionId, auctionData);
      }
    }
    
    const updatedAuction = await storage.getAuctionById(auctionId);
    const updatedProduct = await storage.getProductById(auction.productId);
    
    res.json({
      auction: updatedAuction,
      product: updatedProduct
    });
  } catch (error) {
    next(error);
  }
});

// ============================================================================
// PATCH 4: Fix Auction Create Endpoint (around line 2370)
// ============================================================================

// REPLACE THE VULNERABLE CREATE AUCTION WITH:
app.post("/api/auctions", validateCSRF, authService.requireAuth, async (req: any, res, next) => {
  try {
    const user = req.user;
    
    if (!user.isSeller) {
      return res.status(403).json({ 
        message: "Unauthorized: Seller account required",
        code: "SELLER_REQUIRED"
      });
    }

    const { product: productData, auction: auctionData } = req.body;

    // SECURITY FIX: Force authenticated user as seller
    const productToCreate = {
      ...productData,
      sellerId: user.id
    };

    const validatedProduct = insertProductSchema.parse(productToCreate);
    const newProduct = await storage.createProduct(validatedProduct);

    const auctionToCreate = {
      ...auctionData,
      productId: newProduct.id,
      status: 'active',
      currentBid: auctionData.startingBid || 0
    };

    const newAuction = await storage.createAuction(auctionToCreate);

    // Emit WebSocket event for new auction
    const io = getIO();
    if (io) {
      io.emit('newAuction', {
        auction: newAuction,
        product: newProduct
      });
    }

    res.status(201).json({
      product: newProduct,
      auction: newAuction
    });
  } catch (error) {
    next(error);
  }
});

// ============================================================================
// PATCH 5: Fix Product Image Upload Endpoint (around line 2635)
// ============================================================================

// REPLACE THE VULNERABLE IMAGE UPLOAD WITH:
app.post("/api/products/:id/images", authService.requireAuth, imageUpload.single('image'), async (req: any, res, next) => {
  try {
    const user = req.user;
    
    if (!user.isSeller) {
      return res.status(403).json({ 
        message: "Unauthorized: Seller account required",
        code: "SELLER_REQUIRED"
      });
    }

    const productId = parseInt(req.params.id);
    const product = await storage.getProductById(productId);

    if (!product) {
      return res.status(404).json({ message: "Product not found" });
    }

    // SECURITY FIX: Verify ownership
    if (product.sellerId !== user.id) {
      return res.status(403).json({ 
        message: "Unauthorized: You can only upload images to your own products",
        code: "OWNERSHIP_REQUIRED"
      });
    }

    if (!req.file) {
      return res.status(400).json({ message: "No image file provided" });
    }

    // Process the uploaded image
    const imageUrl = await uploadToSupabaseStorage(req.file, 'product-images');
    
    const productImage = await storage.createProductImage({
      productId: productId,
      imageUrl: imageUrl,
      isPrimary: false
    });

    res.json(productImage);
  } catch (error) {
    next(error);
  }
});

// ============================================================================
// PATCH 6: Fix Product Image Delete Endpoint (around line 2705)
// ============================================================================

// REPLACE THE VULNERABLE IMAGE DELETE WITH:
app.delete("/api/products/:productId/images/:imageId", authService.requireAuth, async (req: any, res, next) => {
  try {
    const user = req.user;
    
    if (!user.isSeller) {
      return res.status(403).json({ 
        message: "Unauthorized: Seller account required",
        code: "SELLER_REQUIRED"
      });
    }

    const productId = parseInt(req.params.productId);
    const imageId = parseInt(req.params.imageId);
    
    const product = await storage.getProductById(productId);

    if (!product) {
      return res.status(404).json({ message: "Product not found" });
    }

    // SECURITY FIX: Verify ownership
    if (product.sellerId !== user.id) {
      return res.status(403).json({ 
        message: "Unauthorized: You can only delete images from your own products",
        code: "OWNERSHIP_REQUIRED"
      });
    }

    const image = await storage.getProductImage(imageId);
    if (!image || image.productId !== productId) {
      return res.status(404).json({ message: "Image not found" });
    }

    // Delete from storage
    if (image.imageUrl) {
      await deleteFromSupabaseStorage(image.imageUrl);
    }

    await storage.deleteProductImage(imageId);
    res.json({ message: "Image deleted successfully" });
  } catch (error) {
    next(error);
  }
});

// ============================================================================
// PATCH 7: Fix Get Seller Products Endpoint (around line 2825)
// ============================================================================

// This endpoint can remain mostly the same but should be clarified:
app.get("/api/seller/products", async (req: any, res, next) => {
  try {
    let sellerId: number;

    // Public viewing: if sellerId is provided in query
    if (req.query.sellerId) {
      sellerId = parseInt(req.query.sellerId as string);
    } 
    // Private viewing: authenticated seller viewing their own products
    else if (req.user && req.user.isSeller) {
      sellerId = req.user.id;
    } 
    else {
      return res.status(400).json({ 
        message: "Seller ID required or must be authenticated as seller",
        code: "SELLER_ID_REQUIRED"
      });
    }

    const products = await storage.getProductsBySellerId(sellerId);
    res.json(products);
  } catch (error) {
    next(error);
  }
});

// ============================================================================
// ADDITIONAL SECURITY RECOMMENDATIONS
// ============================================================================

/**
 * 1. Update getAuthenticatedUser to use the auth-service.ts instead:
 *    - Remove the current getAuthenticatedUser function
 *    - Import and use authService.requireAuth middleware
 * 
 * 2. Add these imports at the top of routes.ts:
 *    import { getAuthService } from './auth-service';
 *    const authService = getAuthService();
 * 
 * 3. Remove all instances where sellerId is accepted from req.body or req.query
 *    for modification operations
 * 
 * 4. Consider adding rate limiting to prevent abuse:
 *    - Product creation/update/delete
 *    - Auction creation/update
 *    - Image uploads
 * 
 * 5. Add audit logging for all modification operations
 * 
 * 6. Implement RBAC (Role-Based Access Control) for admin operations
 */